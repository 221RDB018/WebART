<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Paintings</title>
    <style>
      body { margin: 0; overflow: hidden; background: black; font-family: Arial, sans-serif; }
      #loading-message {
        position: absolute;
        top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.7); color: white;
        padding: 15px; border-radius: 10px; font-size: 16px;
      }
      #ar-failure {
        display: none; position: absolute; bottom: 50px;
        left: 50%; transform: translateX(-50%);
        background: red; color: white; padding: 10px; border-radius: 5px;
      }
      #image-upload {
        position: absolute; top: 10px; left: 10px; z-index: 10;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px;
      }
      #timer-display {
        position: absolute; top: 10px; right: 10px; z-index: 10;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px;
        color: black; font-weight: bold;
      }
    </style>
  </head>
  <body>
    <input type="file" id="image-upload" accept="image/*">
    <div id="loading-message">Move your phone to detect a wall</div>
    <div id="ar-failure">AR is not tracking</div>
    <div id="timer-display"></div>
    <script type="importmap">
      { "imports": { "three": "https://threejs.org/build/three.module.js" } }
    </script>
    <script type="module">
import * as THREE from 'three';
import { XRButton } from 'https://threejs.org/examples/jsm/webxr/XRButton.js';
import { RGBELoader } from 'https://threejs.org/examples/jsm/loaders/RGBELoader.js';
import { TransformControls } from 'https://threejs.org/examples/jsm/controls/TransformControls.js';
import { XREstimatedLight } from 'https://threejs.org/examples/jsm/webxr/XREstimatedLight.js';

let scene, camera, renderer;
let model, hitTestSource = null, hitTestSourceRequested = false;
let placed = false;
let controller;
let controls, raycaster;
let defaultEnvironment;
let controlsVisible = false;

// Получаем параметры из URL
const urlParams = new URLSearchParams(window.location.search);
const artworkId = urlParams.get('artworkId');
const frameId = urlParams.get('frameId');

// Инициализируем данные из artworks.ts
const initialArtworks = {
  "1": {
    id: "1",
    title: "Abstract Harmony",
    artist: "Elena Rivera",
    imageUrl: "/abstract-1.jpg",
    dimensions: { width: 70, height: 53 }
  },
  "2": {
    id: "2",
    title: "Serene Landscape",
    artist: "Michael Chen",
    imageUrl: "/landscape-1.jpg",
    dimensions: { width: 96, height: 64 }
  },
  "3": {
    id: "3",
    title: "Urban Perspective",
    artist: "James Wilson",
    imageUrl: "/urban-1.jpg",
    dimensions: { width: 72, height: 48 }
  },
  "4": {
    id: "4",
    title: "Ethereal Bloom",
    artist: "Sofia Nakamura",
    imageUrl: "/floral-1.jpg",
    dimensions: { width: 65, height: 43 }
  },
  "5": {
    id: "5",
    title: "Contemplation",
    artist: "Marcus Johnson",
    imageUrl: "/portrait-1.jpg",
    dimensions: { width: 44, height: 66 }
  },
  "6": {
    id: "6",
    title: "Geometric Dreams",
    artist: "Leila Ahmed",
    imageUrl: "/abstract-2.jpg",
    dimensions: { width: 86, height: 57 }
  }
};

// Получаем данные о картинах из localStorage или используем начальные данные
let artworks = JSON.parse(localStorage.getItem('webarArtworks') || '{}');
console.log(artworks);

// Если в localStorage нет данных или они устарели, используем начальные данные
if (Object.keys(artworks).length === 0 || !artworks["1"]) {
  artworks = initialArtworks;
  localStorage.setItem('webarArtworks', JSON.stringify(artworks));
}

// Данные о рамках
const frames = {
  "frame-1": {
    id: "frame-1",
    name: "Classic Black",
    color: "#000000",
    metalness: 0.1,
    roughness: 0.75,
    envMapIntensity: 1.0
  },
  "frame-2": {
    id: "frame-2",
    name: "Modern White",
    color: "#FFFFFF",
    metalness: 0.9,
    roughness: 0.1,
    envMapIntensity: 1.0
  },
  "frame-3": {
    id: "frame-3",
    name: "Natural Wood",
    color: "#C19A6B",
    metalness: 0.1,
    roughness: 0.75,
    envMapIntensity: 1.0
  },
  "frame-4": {
    id: "frame-4",
    name: "Gold Finish",
    color: "#D4AF37",
    metalness: 0.9,
    roughness: 0.1,
    envMapIntensity: 1.0
  },
  "frame-5": {
    id: "frame-5",
    name: "Silver Metal",
    color: "#C0C0C0",
    metalness: 0.9,
    roughness: 0.1,
    envMapIntensity: 1.0
  }
};

// Получаем данные о картине и рамке
function getArtworkData() {
  const artwork = artworks[artworkId];
  const frame = frameId ? frames[frameId] : null;
  
  if (!artwork) {
    throw new Error('Artwork not found');
  }
  
  return { artwork, frame };
}

function createArtworkModel(artwork, frame) {
  const group = new THREE.Group();
  
  // Получаем размеры из URL параметров или используем оригинальные размеры
  const customWidth = urlParams.get('width') ? parseFloat(urlParams.get('width')) : artwork.dimensions.width;
  const customHeight = urlParams.get('height') ? parseFloat(urlParams.get('height')) : artwork.dimensions.height;
  
  // Конвертируем размеры из см в метры
  const width = customWidth / 100;
  const height = customHeight / 100;
  console.log('Custom dimensions:', width, height);
  
  // Создаем картину
  const paintingGeometry = new THREE.PlaneGeometry(width, height);
  const texture = new THREE.TextureLoader().load(artwork.imageUrl);
  const paintingMaterial = new THREE.MeshStandardMaterial({
    map: texture,
    metalness: 0,
    roughness: 1,
    color: 0x999999
  });
  const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
  painting.name = 'painting';
  group.add(painting);
  
  // Создаем рамку если она выбрана
  if (frame) {
    const frameThickness = 0.02; // 2 см
    const frameDepth = 0.015;    // 1.5 см
    
    const frameMaterial = new THREE.MeshStandardMaterial({
      color: frame.color,
      metalness: frame.metalness,
      roughness: frame.roughness,
      envMapIntensity: frame.envMapIntensity
    });
    
    function createFramePiece(width, height, depth, y = 0, x = 0) {
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), frameMaterial);
      mesh.position.set(x, y, 0);
      return mesh;
    }
    
    // Создаем части рамки с учетом размеров картины
    const topFrame = createFramePiece(width + frameThickness * 2, frameThickness, frameDepth, height/2 + frameThickness/2);
    const bottomFrame = createFramePiece(width + frameThickness * 2, frameThickness, frameDepth, -height/2 - frameThickness/2);
    const leftFrame = createFramePiece(frameThickness, height + frameThickness * 2, frameDepth, 0, -width/2 - frameThickness/2);
    const rightFrame = createFramePiece(frameThickness, height + frameThickness * 2, frameDepth, 0, width/2 + frameThickness/2);
    
    group.add(topFrame);
    group.add(bottomFrame);
    group.add(leftFrame);
    group.add(rightFrame);
  }
  
  return group;
}

async function init() {
  // Загружаем данные
  const { artwork, frame } = await getArtworkData();
  
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 10);
  scene.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;

  const xrButton = XRButton.createButton(renderer, {
    requiredFeatures: ['hit-test'],
    optionalFeatures: ['local-floor', 'light-estimation']
  });

  document.body.appendChild(xrButton);

  new RGBELoader()
    .setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/')
    .load('studio_small_03_1k.hdr', texture => {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      defaultEnvironment = texture;
      scene.environment = defaultEnvironment;
    });

  const defaultLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  defaultLight.position.set(0.5, 1, 0.25);
  scene.add(defaultLight);

  // Создаем модель с учетом данных о картине и рамке
  model = createArtworkModel(artwork, frame);
  model.visible = false;
  scene.add(model);

  raycaster = new THREE.Raycaster();

  controls = new TransformControls(camera, renderer.domElement);
  controls.visible = false;
  scene.add(controls.getHelper());

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  controller.addEventListener('selectstart', onControllerEvent);
  controller.addEventListener('selectend', onControllerEvent);
  controller.addEventListener('move', onControllerEvent);
  scene.add(controller);

  const xrLight = new XREstimatedLight(renderer);
  xrLight.addEventListener('estimationstart', () => {
    scene.add(xrLight); scene.remove(defaultLight);
    if (xrLight.environment) scene.environment = xrLight.environment;
  });
  xrLight.addEventListener('estimationend', () => {
    scene.add(defaultLight); scene.remove(xrLight);
    scene.environment = defaultEnvironment;
  });

  renderer.setAnimationLoop(render);
  window.addEventListener('resize', onWindowResize);
  
//   // Инициализация элемента отображения таймера
//   timerDisplay = document.getElementById('timer-display');
//   timerDisplay.textContent = 'Время: 0.000 сек';

}

function onSelect() {
  if (!placed) {
    model.visible = true;
    model.position.set(0,1,-1).applyMatrix4(camera.matrixWorld);
    model.quaternion.copy(camera.quaternion);
    placed = true;
    controls.attach(model);
    controls.visible = false;
    controlsVisible = false;
    
    // const placementTime = performance.now() - appStartTime;
    // console.log(`Время размещения модели: ${placementTime.toFixed(3)} мс`);
    // timerDisplay.textContent = `Время: ${(placementTime/1000).toFixed(3)} сек`;
  } else {
    raycaster.setFromXRController(controller);
    const intersects = raycaster.intersectObject(model, true);
    if (intersects.length > 0) {
      controls.attach(model);
      controls.visible = true;
      controlsVisible = true;
    } else {
      controls.detach();
      controls.visible = false;
      controlsVisible = false;
    }
  }
}

function onControllerEvent(event) {
  controls.getRaycaster().setFromXRController(controller);
  switch(event.type) {
    case 'selectstart': controls.pointerDown(null); break;
    case 'selectend':   controls.pointerUp(null);   break;
    case 'move':        controls.pointerHover(null); controls.pointerMove(null); break;
  }
}

async function setupHitTestSource() {
  const session = renderer.xr.getSession();
  const space = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({ space });
  hitTestSourceRequested = true;
}

function render(timestamp, frame) {
  if (frame && !placed) {
    const refSpace = renderer.xr.getReferenceSpace();
    if (!hitTestSourceRequested) {
      setupHitTestSource();
    }

    if (hitTestSource) {
      const hits = frame.getHitTestResults(hitTestSource);
      if (hits.length > 0) {
        const pose = hits[0].getPose(refSpace);
        if (Math.abs(pose.transform.orientation.y) < 0.75) {
          model.visible = true;
          model.position.copy(pose.transform.position);
          placed = true;
          
          // const placementTime = performance.now() - appStartTime;
          // console.log(`Время до размещения модели через hit-test: ${placementTime.toFixed(3)} мс`);
          // timerDisplay.textContent = `Время: ${(placementTime/1000).toFixed(3)} сек`;
        }
      }
    }
  }

  controls.update();
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

init();
    </script>
  </body>
</html>